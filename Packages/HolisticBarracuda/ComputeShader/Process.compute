#pragma kernel LetterBoxImage
#pragma kernel FaceRecon
#pragma kernel IrisRecon
#pragma kernel HandRegionDetect
#pragma kernel HandCrop
#pragma kernel HandKeyPointPost

#pragma kernel bbox_kernel
#pragma kernel HandsCrop
#pragma kernel HandsKeyPointPost

#include "HandRegion.hlsl"
#include "LowPassFilter.hlsl"
#include "Misc.hlsl"
#include "Packages/jp.keijiro.mediapipe.blazepalm/Shader/Struct.hlsl"


float2 _spadScale;
uint _letterboxWidth;
sampler2D _letterboxInput;
RWTexture2D<float4> _letterboxTexture;

// Generate letter-box image texture.
[numthreads(8, 8, 1)]
void LetterBoxImage(uint2 id : SV_DispatchThreadID)
{
    if (any(id > _letterboxWidth)) return;

    // UV coordinates
    float2 uv = (id + 0.5) / _letterboxWidth;

    // Scaling
    uv = (uv - 0.5) * _spadScale + 0.5;

    // UV gradients
    float2 duv_dx = float2(+1.0 / _letterboxWidth * _spadScale.x, 0);
    float2 duv_dy = float2(0, -1.0 / _letterboxWidth * _spadScale.y);

    // Texture sample
    float3 rgb = tex2Dgrad(_letterboxInput, uv, duv_dx, duv_dy).rgb;

    // Bounding
    rgb *= all(uv > 0) && all (uv < 1);

    _letterboxTexture[id] = float4(rgb, 1);
}


StructuredBuffer<float4> _faceVertices;
RWStructuredBuffer<float4> _faceReconVertices;

[numthreads(1,1,1)]
void FaceRecon(uint3 id : SV_DispatchThreadID)
{ 
    float4 p = _faceVertices[id.x];
    p.xy = (p.xy - 0.5) * _spadScale + 0.5;
    _faceReconVertices[id.x] = p;
}


StructuredBuffer<float4> _irisVertices;
float4x4 _irisCropMatrix;
RWStructuredBuffer<float4> _irisReconVertices;

[numthreads(1,1,1)]
void IrisRecon(uint3 id : SV_DispatchThreadID)
{ 
    float4 p = mul(_irisCropMatrix, _irisVertices[id.x]);
    p.xy = (p.xy - 0.5) * _spadScale + 0.5;
    _irisReconVertices[id.x] = p;
}


int _isRight;
float _bboxDt;
StructuredBuffer<float4> _poseInput;
RWStructuredBuffer<HandRegion> _bboxRegion;

[numthreads(1,1,1)]
void HandRegionDetect(uint3 id : SV_DispatchThreadID)
{
    float4 wrist = _poseInput[15 + _isRight];
    float4 index = _poseInput[19 + _isRight];
    float4 pinky = _poseInput[17 + _isRight];
    // Estimate middle finger.
    float2 middle = (2.0f * index.xy + pinky.xy) / 3.0f;
    // Bounding box size as double distance from middle finger to wrist.
    float boxSize = 2.0f * sqrt((middle.x - wrist.x) * (middle.x - wrist.x) + (middle.y - wrist.y) * (middle.y - wrist.y));

    // bounding box
    float2 boundingBoxCenter = middle;
    float boundingBoxSize = boxSize * 2.0f;

    // bounding box angle
    float target = PI * 0.5;
    float2 up = middle - wrist.xy;
    float boundingBoxAngle = target - atan2(-up.y, up.x);

    const float4 box = float4(boundingBoxCenter, boundingBoxSize, boundingBoxAngle);
    
     // Hand region structure. We're going to update this.
    HandRegion region = _bboxRegion[0];

    // Low pass filter parameters and input vector
    const float3 lpf_params = float3(2, 1.5f, _bboxDt);
    region.dBox = lpf_Step_dx(box, region.box, region.dBox, lpf_params);
    region.box = lpf_Step_x(box, region.box, region.dBox, lpf_params);

    // Region crop matrix update
    float4x4 m1 = makeTranslationMatrix(region.box.xy - region.box.z / 2);
    float4x4 m2 = makeScalingMatrix(region.box.z);
    float4x4 m3 = makeTranslationMatrix(0.5);
    float4x4 m4 = makeRotationMatrix(region.box.w);
    float4x4 m5 = makeTranslationMatrix(-0.5);
    region.cropMatrix = mul(mul(mul(mul(m1, m2), m3), m4), m5);

    // Compute buffer update
    _bboxRegion[0] = region;
}


int _handCropImageSize;
sampler2D _handCropInput;
StructuredBuffer<HandRegion> _handCropRegion;
RWTexture2D<float4> _handCropOutput;

[numthreads(8, 8, 1)]
void HandCrop(uint2 id : SV_DispatchThreadID)
{
    float4x4 xform = _handCropRegion[0].cropMatrix;

    // UV coordinates
    float2 uv = (id + 0.5) / _handCropImageSize;
    uv.y = 1 - uv.y;
    uv = mul(xform, float4(uv, 0, 1)).xy;

    // UV gradients
    float2 duv_dx = mul(xform, float4(1.0 / _handCropImageSize, 0, 0, 0)).xy;
    float2 duv_dy = mul(xform, float4(0, -1.0 / _handCropImageSize, 0, 0)).xy;

    // Texture sample
    float3 rgb = tex2Dgrad(_handCropInput, uv, duv_dx, duv_dy).rgb;

    _handCropOutput[id] = float4(rgb, 1);
}

 
#define HAND_KEYPOINT_COUNT 21

float _handPostDt;
StructuredBuffer<float4> _handPostInput;
StructuredBuffer<HandRegion> _handPostRegion;
RWStructuredBuffer<float4> _handPostOutput;

[numthreads(HAND_KEYPOINT_COUNT, 1, 1)]
void HandKeyPointPost(uint id : SV_DispatchThreadID)
{
    HandRegion region = _handPostRegion[0];

    float3 x = _handPostInput[id + 1].xyz;
    x.y = 1.0f - x.y;
    float3 p_x = _handPostOutput[id].xyz;
    float3 p_dx = _handPostOutput[id + HAND_KEYPOINT_COUNT].xyz;

    x = mul(region.cropMatrix, float4(x, 1)).xyz;

    float3 lpf_params = float3(30, 1.5, _handPostDt);
    float3 dx = lpf_Step_dx(x, p_x, p_dx, lpf_params);
    x = lpf_Step_x(x, p_x, dx, lpf_params);

    _handPostOutput[id] = float4(x, 1);
    _handPostOutput[id + HAND_KEYPOINT_COUNT] = float4(dx, 1);
}











float _bbox_dt;

StructuredBuffer<PalmDetection> _bbox_palm;
ByteAddressBuffer _bbox_count;

RWStructuredBuffer<HandRegion> _bbox_region;

[numthreads(1, 1, 1)]
void bbox_kernel(uint id : SV_DispatchThreadID)
{
    uint entry_count = _bbox_count.Load(0);
    if (entry_count == 0) return;

    entry_count = min(entry_count, 2); // 3以上が出るときの対策

    HandRegion pRegion0 = _bbox_region[0];
    HandRegion pRegion1 = _bbox_region[1];

    for(uint i = 0; i<entry_count; i++){

        // Input from the palm detection model
        const PalmDetection palm = _bbox_palm[i];

        // Palm region size (squarified and enlarged bounding box)
        float size = max(palm.extent.x, palm.extent.y) * 3;

        // Palm angle
        const float2 up = palm.keyPoints[3] - palm.keyPoints[0];
        float angle = atan2(up.y, up.x) - PI / 2;

        const float4 box = float4(palm.center, size, angle);

        float distance0 = distance(box.xy, pRegion0.box.xy);
        float distance1 = distance(box.xy, pRegion1.box.xy);

        HandRegion region = pRegion0;
        if(distance0 > distance1) region = pRegion1;

        // Low pass filter parameters and input vector
        const float3 lpf_params = float3(2, 1.5f, _bbox_dt);
        region.dBox = lpf_Step_dx(box, region.box, region.dBox, lpf_params);
        region.box = lpf_Step_x(box, region.box, region.dBox, lpf_params);

        // Region crop matrix update
        float4x4 m1 = makeTranslationMatrix(region.box.xy - region.box.z / 2);
        float4x4 m2 = makeScalingMatrix(region.box.z);
        float4x4 m3 = makeTranslationMatrix(0.5);
        float4x4 m4 = makeRotationMatrix(region.box.w);
        float4x4 m5 = makeTranslationMatrix(-0.5 + float2(0, 0.15));
        region.cropMatrix = mul(mul(mul(mul(m1, m2), m3), m4), m5);

        // Compute buffer update
        _bbox_region[i] = region;
    }
}



int _handsIndex;
int _handsCropImageSize;
sampler2D _handsCropInput;
StructuredBuffer<HandRegion> _handsCropRegion;
RWStructuredBuffer<float> _handsCropOutput;

[numthreads(8, 8, 1)]
void HandsCrop(uint2 id : SV_DispatchThreadID)
{
    float4x4 xform = _handsCropRegion[_handsIndex].cropMatrix;

    // UV coordinates
    float2 uv = (id + 0.5) / _handsCropImageSize;
    uv.y = 1 - uv.y;
    uv = mul(xform, float4(uv, 0, 1)).xy;
    uv = (uv - 0.5) * _spadScale + 0.5;

    // UV gradients
    float2 duv_dx = mul(xform, float4(1.0 / _handsCropImageSize, 0, 0, 0)).xy;
    float2 duv_dy = mul(xform, float4(0, -1.0 / _handsCropImageSize, 0, 0)).xy;

    // Texture sample
    float3 rgb = tex2Dgrad(_handsCropInput, uv, duv_dx, duv_dy).rgb;

    // _handsCropOutput[id] = float4(rgb, 1);

     uint offs = (id.y * _handsCropImageSize + id.x) * 3;
    _handsCropOutput[offs + 0] = rgb.r;
    _handsCropOutput[offs + 1] = rgb.g;
    _handsCropOutput[offs + 2] = rgb.b;
}


float _handsPostDt;
StructuredBuffer<float4> _handsPostInput;
StructuredBuffer<HandRegion> _handsPostRegion;
RWStructuredBuffer<float4> _handsPostLeftOutput;
RWStructuredBuffer<float4> _handsPostRightOutput;

[numthreads(HAND_KEYPOINT_COUNT, 1, 1)]
void HandsKeyPointPost(uint id : SV_DispatchThreadID)
{
    HandRegion region = _handsPostRegion[_handsIndex];
    float handness = _handsPostInput[0].y;

    float3 x = _handsPostInput[id + 1].xyz;
    // x.y = 1.0f - x.y;
    float3 p_x = (handness > 0.5f) ? _handsPostRightOutput[id].xyz : _handsPostLeftOutput[id].xyz;
    float3 p_dx = (handness > 0.5f) ? _handsPostRightOutput[id + HAND_KEYPOINT_COUNT].xyz : _handsPostLeftOutput[id + HAND_KEYPOINT_COUNT].xyz;

    x = mul(region.cropMatrix, float4(x, 1)).xyz;
    x.xy = (x.xy - 0.5) * _spadScale + 0.5;

    float3 lpf_params = float3(30, 1.5, _handsPostDt);
    float3 dx = lpf_Step_dx(x, p_x, p_dx, lpf_params);
    x = lpf_Step_x(x, p_x, dx, lpf_params);

    if(handness > 0.5f){
        _handsPostRightOutput[id] = float4(x, 1);
        _handsPostRightOutput[id + HAND_KEYPOINT_COUNT] = float4(dx, 1);
    }
    else{
        _handsPostLeftOutput[id] = float4(x, 1);
        _handsPostLeftOutput[id + HAND_KEYPOINT_COUNT] = float4(dx, 1);
    }
}
